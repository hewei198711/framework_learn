import os
import string
import subprocess
import sys
from typing import Text, List, Tuple, Dict, Set, NoReturn

import jinja2
from loguru import logger
from sentry_sdk import capture_exception

from httprunner import exceptions, __version__
from httprunner.compat import (
    ensure_testcase_v3_api,
    ensure_testcase_v3,
    convert_variables,
    ensure_path_sep,
)
from httprunner.loader import (
    load_folder_files,
    load_test_file,
    load_testcase,
    load_testsuite,
    load_project_meta,
    convert_relative_project_root_dir,
)
from httprunner.response import uniform_validator
from httprunner.utils import merge_variables, is_support_multiprocessing

""" cache converted pytest files, avoid duplicate making
    缓存转换后的pytest文件，避免重复制作
"""
pytest_files_made_cache_mapping: Dict[Text, Text] = {}

""" save generated pytest files to run, except referenced testcase
    保存生成的pytest文件以运行，引用的testcase除外
"""
pytest_files_run_set: Set = set()

__TEMPLATE__ = jinja2.Template(
    """# NOTE: Generated By HttpRunner v{{ version }}
# FROM: {{ testcase_path }}

{% if imports_list and diff_levels > 0 %}
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__){% for _ in range(diff_levels) %}.parent{% endfor %}))
{% endif %}

{% if parameters %}
import pytest
from httprunner import Parameters
{% endif %}

from httprunner import HttpRunner, Config, Step, RunRequest, RunTestCase
{% for import_str in imports_list %}
{{ import_str }}
{% endfor %}

class {{ class_name }}(HttpRunner):

    {% if parameters %}
    @pytest.mark.parametrize("param", Parameters({{parameters}}))
    def test_start(self, param):
        super().test_start(param)
    {% endif %}

    config = {{ config_chain_style }}

    teststeps = [
        {% for step_chain_style in teststeps_chain_style %}
            {{ step_chain_style }},
        {% endfor %}
    ]

if __name__ == "__main__":
    {{ class_name }}().test_start()

"""
)

# 返回基于debugtalk.py路径的绝对路径
def __ensure_absolute(path: Text) -> Text:
    # 判断路径结尾类型
    if path.startswith("./"):
        # Linux/Darwin, hrun ./test.yml
        path = path[len("./") :]
    elif path.startswith(".\\"):
        # Windows, hrun .\\test.yml
        path = path[len(".\\") :]
    # 确保linux和windows的不同路径分隔符兼容
    path = ensure_path_sep(path)
    # 返回debugtalk.py的路径
    project_meta = load_project_meta(path)

    # 判断是否是绝对路径
    if os.path.isabs(path):
        absolute_path = path
    else:
        # 变成绝对路径，project_meta.RootDir是项目根路径
        absolute_path = os.path.join(project_meta.RootDir, path)
    # 如果不是文件
    if not os.path.isfile(absolute_path):
        logger.error(f"Invalid testcase file path: {absolute_path}")
        sys.exit(1)

    return absolute_path

# 确保文件路径对pytest有效，处理目录名dot/hyphen/space
def ensure_file_abs_path_valid(file_abs_path: Text) -> Text:
    """ ensure file path valid for pytest, handle cases when directory name includes dot/hyphen/space

    Args:
        file_abs_path: absolute file path

    Returns:
        ensured valid absolute file path

    """
    # 获取项目的路径、debugtalk里的函数，debugtalk的路径
    project_meta = load_project_meta(file_abs_path)
    # 获取路径和文件后缀名
    raw_abs_file_name, file_suffix = os.path.splitext(file_abs_path)
    # 转为小写
    file_suffix = file_suffix.lower()
    # 获取基于project_meta.RootDir将绝对路径转换为相对路径
    raw_file_relative_name = convert_relative_project_root_dir(raw_abs_file_name)
    # 相对路径为空，返回file_abs_path
    if raw_file_relative_name == "":
        return file_abs_path

    path_names = []
    # 将路径分隔截取
    for name in raw_file_relative_name.rstrip(os.sep).split(os.sep):
        # 如果第一位为数字
        if name[0] in string.digits:
            # ensure file name not startswith digit
            # 19 => T19, 2C => T2C
            name = f"T{name}"
        # 如果以.结尾
        if name.startswith("."):
            # avoid ".csv" been converted to "_csv"
            pass
        else:
            # handle cases when directory name includes dot/hyphen/space
            # 处理目录名包含点/连字符/空格的情况
            name = name.replace(" ", "_").replace(".", "_").replace("-", "_")
        # 存入路径名列表
        path_names.append(name)
    # 将路径名重新拼接起来
    new_file_path = os.path.join(
        project_meta.RootDir, f"{os.sep.join(path_names)}{file_suffix}"
    )
    # 返回新的绝对路径
    return new_file_path

# 确保pytest文件位于python模块中，按需生成__init__.py文件
def __ensure_testcase_module(path: Text) -> NoReturn:
    """ ensure pytest files are in python module, generate __init__.py on demand
    """
    init_file = os.path.join(os.path.dirname(path), "__init__.py")
    if os.path.isfile(init_file):
        return

    with open(init_file, "w", encoding="utf-8") as f:
        f.write("# NOTICE: Generated By HttpRunner. DO NOT EDIT!\n")

# 将单个YAML/JSON测试用例路径转换为python文件
def convert_testcase_path(testcase_abs_path: Text) -> Tuple[Text, Text]:
    """convert single YAML/JSON testcase path to python file"""
    testcase_new_path = ensure_file_abs_path_valid(testcase_abs_path)

    dir_path = os.path.dirname(testcase_new_path)
    file_name, _ = os.path.splitext(os.path.basename(testcase_new_path))
    testcase_python_abs_path = os.path.join(dir_path, f"{file_name}_test.py")

    # convert title case, e.g. request_with_variables => RequestWithVariables
    name_in_title_case = file_name.title().replace("_", "")

    return testcase_python_abs_path, name_in_title_case

# 用“black”设置pytest的代码格式
def format_pytest_with_black(*python_paths: Text) -> NoReturn:
    logger.info("format pytest cases with black ...")
    try:
        if is_support_multiprocessing() or len(python_paths) <= 1:
            subprocess.run(["black", *python_paths])
        else:
            logger.warning(
                f"this system does not support multiprocessing well, format files one by one ..."
            )
            # 启用多线程处理
            [subprocess.run(["black", path]) for path in python_paths]
    except subprocess.CalledProcessError as ex:
        capture_exception(ex)
        logger.error(ex)
        sys.exit(1)
    except FileNotFoundError:
        err_msg = """
missing dependency tool: black
install black manually and try again:
$ pip install black
"""
        logger.error(err_msg)
        sys.exit(1)

# 创建配置链样式
def make_config_chain_style(config: Dict) -> Text:
    config_chain_style = f'Config("{config["name"]}")'

    if config["variables"]:
        variables = config["variables"]
        config_chain_style += f".variables(**{variables})"

    if "base_url" in config:
        config_chain_style += f'.base_url("{config["base_url"]}")'

    if "verify" in config:
        config_chain_style += f'.verify({config["verify"]})'

    if "export" in config:
        config_chain_style += f'.export(*{config["export"]})'

    if "weight" in config:
        config_chain_style += f'.locust_weight({config["weight"]})'

    return config_chain_style

# 制作请求链样式
def make_request_chain_style(request: Dict) -> Text:
    method = request["method"].lower()
    url = request["url"]
    request_chain_style = f'.{method}("{url}")'

    if "params" in request:
        params = request["params"]
        request_chain_style += f".with_params(**{params})"

    if "headers" in request:
        headers = request["headers"]
        request_chain_style += f".with_headers(**{headers})"

    if "cookies" in request:
        cookies = request["cookies"]
        request_chain_style += f".with_cookies(**{cookies})"

    if "data" in request:
        data = request["data"]
        if isinstance(data, Text):
            data = f'"{data}"'
        request_chain_style += f".with_data({data})"

    if "json" in request:
        req_json = request["json"]
        if isinstance(req_json, Text):
            req_json = f'"{req_json}"'
        request_chain_style += f".with_json({req_json})"

    if "timeout" in request:
        timeout = request["timeout"]
        request_chain_style += f".set_timeout({timeout})"

    if "verify" in request:
        verify = request["verify"]
        request_chain_style += f".set_verify({verify})"

    if "allow_redirects" in request:
        allow_redirects = request["allow_redirects"]
        request_chain_style += f".set_allow_redirects({allow_redirects})"

    if "upload" in request:
        upload = request["upload"]
        request_chain_style += f".upload(**{upload})"

    return request_chain_style

# 制作teststep链样式
def make_teststep_chain_style(teststep: Dict) -> Text:
    if teststep.get("request"):
        step_info = f'RunRequest("{teststep["name"]}")'
    elif teststep.get("testcase"):
        step_info = f'RunTestCase("{teststep["name"]}")'
    else:
        raise exceptions.TestCaseFormatError(f"Invalid teststep: {teststep}")

    if "variables" in teststep:
        variables = teststep["variables"]
        step_info += f".with_variables(**{variables})"

    if "setup_hooks" in teststep:
        setup_hooks = teststep["setup_hooks"]
        for hook in setup_hooks:
            if isinstance(hook, Text):
                step_info += f'.setup_hook("{hook}")'
            elif isinstance(hook, Dict) and len(hook) == 1:
                assign_var_name, hook_content = list(hook.items())[0]
                step_info += f'.setup_hook("{hook_content}", "{assign_var_name}")'
            else:
                raise exceptions.TestCaseFormatError(f"Invalid setup hook: {hook}")

    if teststep.get("request"):
        # 制作请求链样式
        step_info += make_request_chain_style(teststep["request"])
    elif teststep.get("testcase"):
        testcase = teststep["testcase"]
        call_ref_testcase = f".call({testcase})"
        # 步骤是其他测试用例
        step_info += call_ref_testcase

    if "teardown_hooks" in teststep:
        teardown_hooks = teststep["teardown_hooks"]
        for hook in teardown_hooks:
            if isinstance(hook, Text):
                step_info += f'.teardown_hook("{hook}")'
            elif isinstance(hook, Dict) and len(hook) == 1:
                assign_var_name, hook_content = list(hook.items())[0]
                # 制作teardown_hook
                step_info += f'.teardown_hook("{hook_content}", "{assign_var_name}")'
            else:
                raise exceptions.TestCaseFormatError(f"Invalid teardown hook: {hook}")

    if "extract" in teststep:
        # request step
        step_info += ".extract()"
        for extract_name, extract_path in teststep["extract"].items():
            step_info += f""".with_jmespath('{extract_path}', '{extract_name}')"""

    if "export" in teststep:
        # reference testcase step
        export: List[Text] = teststep["export"]
        step_info += f".export(*{export})"

    if "validate" in teststep:
        step_info += ".validate()"

        for v in teststep["validate"]:
            validator = uniform_validator(v)
            assert_method = validator["assert"]
            check = validator["check"]
            if '"' in check:
                # e.g. body."user-agent" => 'body."user-agent"'
                check = f"'{check}'"
            else:
                check = f'"{check}"'
            expect = validator["expect"]
            if isinstance(expect, Text):
                expect = f'"{expect}"'

            message = validator["message"]
            if message:
                step_info += f".assert_{assert_method}({check}, {expect}, '{message}')"
            else:
                step_info += f".assert_{assert_method}({check}, {expect})"

    return f"Step({step_info})"

# 将有效的testcase dict转换为pytest文件路径
def make_testcase(testcase: Dict, dir_path: Text = None) -> Text:
    """
    convert valid testcase dict to pytest file path
    :param testcase:
                    {
                    "config": {
                        "name": "testcase description",
                        "variables": {},
                        "path":"api/test",
                    },
                    "teststeps": [
                        {
                            "name": "/api/user/login",
                            "request": {
                                "url": "http://127.0.0.1:8000/api/user/login",
                                "method": "POST",
                                "headers": {
                                    "Content-Type": "application/json;charset=UTF-8",
                                    "User-Agent": "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.82 Safari/537.36",
                                },
                                "json": {
                                    "username": "1",
                                    "password": "2"
                                }
                            },
                            "validate": [
                                {
                                    "eq": [
                                        "status_code",
                                        200
                                    ]
                                },
                            ]
                        },
                    ]
                }
    :param dir_path:
    :return:
    """
    """"""
    # ensure compatibility with testcase format v2
    # 确保与testcase格式v2兼容，返回一个v3版本的测试用例
    testcase = ensure_testcase_v3(testcase)

    # validate testcase format 验证测试用例格式
    load_testcase(testcase)

    # 获取debugtalk.py的绝对路径
    testcase_abs_path = __ensure_absolute(testcase["config"]["path"])
    logger.info(f"start to make testcase: {testcase_abs_path}")
    # 获取testcase的py路径和testcase的类名
    testcase_python_abs_path, testcase_cls_name = convert_testcase_path(
        testcase_abs_path
    )
    if dir_path:
        # 拼接成测试用例路径
        testcase_python_abs_path = os.path.join(
            dir_path, os.path.basename(testcase_python_abs_path)
        )

    global pytest_files_made_cache_mapping
    # 如果该文件在pytest缓存列表里
    if testcase_python_abs_path in pytest_files_made_cache_mapping:
        return testcase_python_abs_path
    # 获取用例配置
    config = testcase["config"]
    # 基于project_meta.RootDir将绝对路径转换为相对路径，并保存到"path"中
    config["path"] = convert_relative_project_root_dir(testcase_python_abs_path)
    # 保存variables，到variables中
    config["variables"] = convert_variables(
        config.get("variables", {}), testcase_abs_path
    )

    # prepare reference testcase
    # 准备解析测试用例
    imports_list = []
    teststeps = testcase["teststeps"]
    # 遍历测试步骤
    for teststep in teststeps:
        # 如果没有测试用例，跳出不本次循环
        if not teststep.get("testcase"):
            continue

        # make ref testcase pytest file
        # 创建一个 pytest 测试用例文件
        # 基于debugtalk.py路径的绝对路径
        ref_testcase_path = __ensure_absolute(teststep["testcase"])
        # 加载testcase/testsuite文件内容，以字典格式返回
        test_content = load_test_file(ref_testcase_path)

        # 如果返回的不是字典
        if not isinstance(test_content, Dict):
            raise exceptions.TestCaseFormatError(f"Invalid teststep: {teststep}")

        # api in v2 format, convert to v3 testcase
        # v2格式的api，转换为v3测试用例
        if "request" in test_content and "name" in test_content:
            test_content = ensure_testcase_v3_api(test_content) # v2格式的api，转换为v3测试用例

        # 赋值test_content的路径
        test_content.setdefault("config", {})["path"] = ref_testcase_path
        # 继续递归make_testcase， 将有效的testcase dict转换为pytest文件路径
        ref_testcase_python_abs_path = make_testcase(test_content)

        # override testcase export 将关联参数导出
        ref_testcase_export: List = test_content["config"].get("export", [])
        # 如果暴露不为空
        if ref_testcase_export:
            # 获取key"export"的value，不存在时为[]
            step_export: List = teststep.setdefault("export", [])
            # 列表中追加列表
            step_export.extend(ref_testcase_export)
            # 去重后添加到export中
            teststep["export"] = list(set(step_export))

        # prepare ref testcase class name
        # 准备ref测试用例类名
        ref_testcase_cls_name = pytest_files_made_cache_mapping[
            ref_testcase_python_abs_path
        ]
        # testcase列表，存放测试用例绝对路径
        teststep["testcase"] = ref_testcase_cls_name

        # prepare import ref testcase  准备导入步骤测试用例
        # 基于project_meta.RootDir将绝对路径转换为相对路径
        ref_testcase_python_relative_path = convert_relative_project_root_dir(
            ref_testcase_python_abs_path
        )
        # 分割路径，返回路径名和文件扩展名的元组
        ref_module_name, _ = os.path.splitext(ref_testcase_python_relative_path)
        # 将路径分隔符替换成“.”
        ref_module_name = ref_module_name.replace(os.sep, ".")
        # 确定导入的测试用例
        import_expr = f"from {ref_module_name} import TestCase{ref_testcase_cls_name} as {ref_testcase_cls_name}"
        if import_expr not in imports_list:
            # 添加到导入列表
            imports_list.append(import_expr)
    # 基于project_meta.RootDir将绝对路径转换为相对路径
    testcase_path = convert_relative_project_root_dir(testcase_abs_path)
    # current file compared to ProjectRootDir
    # 当前文件与ProjectRootDir的比较
    diff_levels = len(testcase_path.split(os.sep))

    data = {
        "version": __version__,
        "testcase_path": testcase_path,
        "diff_levels": diff_levels,
        "class_name": f"TestCase{testcase_cls_name}",
        "imports_list": imports_list,
        "config_chain_style": make_config_chain_style(config),
        "parameters": config.get("parameters"),
        "teststeps_chain_style": [
            make_teststep_chain_style(step) for step in teststeps
        ],
    }
    content = __TEMPLATE__.render(data)

    # ensure new file's directory exists
    # 确保新文件的目录存在
    dir_path = os.path.dirname(testcase_python_abs_path)
    if not os.path.exists(dir_path):
        os.makedirs(dir_path)
    # 把内容写入py文件
    with open(testcase_python_abs_path, "w", encoding="utf-8") as f:
        f.write(content)
    # 把py文件路径当key，类名为值
    pytest_files_made_cache_mapping[testcase_python_abs_path] = testcase_cls_name
    # 确保pytest文件位于python模块中，按需生成__init__.py文件
    __ensure_testcase_module(testcase_python_abs_path)
    # 生成的测试用例
    logger.info(f"generated testcase: {testcase_python_abs_path}")
    # 返回testcase的py路径
    return testcase_python_abs_path

# 使用testcases将有效的testsuite dict转换为pytest文件到文件夹中
def make_testsuite(testsuite: Dict) -> NoReturn:
    """convert valid testsuite dict to pytest folder with testcases"""
    # validate testsuite format
    # 验证测试套件格式
    load_testsuite(testsuite)

    testsuite_config = testsuite["config"]
    testsuite_path = testsuite_config["path"]
    # 返回variables的字典格式{"var1": 1,"var2": 2}
    testsuite_variables = convert_variables(
        testsuite_config.get("variables", {}), testsuite_path
    )

    logger.info(f"start to make testsuite: {testsuite_path}")

    # create directory with testsuite file name, put its testcases under this directory
    #  使用testsuite文件名创建目录，将其testcases放在此目录下
    testsuite_path = ensure_file_abs_path_valid(testsuite_path) # 确保绝对路径有效
    # 返回路径名和文件扩展名的元组
    testsuite_dir, file_suffix = os.path.splitext(testsuite_path)
    # demo_testsuite.yml => demo_testsuite_yml
    testsuite_dir = f"{testsuite_dir}_{file_suffix.lstrip('.')}"

    for testcase in testsuite["testcases"]:
        # get referenced testcase content
        #  获取引用的测试用例内容
        testcase_file = testcase["testcase"]
        # 返回基于debugtalk.py路径的绝对路径
        testcase_path = __ensure_absolute(testcase_file)
        # 加载testcase/testsuite文件内容
        testcase_dict = load_test_file(testcase_path)
        testcase_dict.setdefault("config", {})
        testcase_dict["config"]["path"] = testcase_path

        # override testcase name
        #  盖测试用例名称
        testcase_dict["config"]["name"] = testcase["name"]
        # override base_url
        #  盖测试用例的base_url
        base_url = testsuite_config.get("base_url") or testcase.get("base_url")
        if base_url:
            testcase_dict["config"]["base_url"] = base_url
        # override verify
        # 盖测试用例的verify
        if "verify" in testsuite_config:
            testcase_dict["config"]["verify"] = testsuite_config["verify"]
        # override variables
        # testsuite testcase variables > testsuite config variables
        # 重写变量
        # testsuite testcase变量>testsuite配置变量
        # 返回variables的字典格式{"var1": 1,"var2": 2}
        testcase_variables = convert_variables(
            testcase.get("variables", {}), testcase_path
        )
        # # 合并两个变量映射，testcase变量具有更高的优先级
        testcase_variables = merge_variables(testcase_variables, testsuite_variables)
        # testsuite testcase variables > testcase config variables
        # testsuite testcase变量>testcase配置变量
        testcase_dict["config"]["variables"] = convert_variables(
            testcase_dict["config"].get("variables", {}), testcase_path
        )
        testcase_dict["config"]["variables"].update(testcase_variables)

        # override weight
        # 盖测试用例的weight
        if "weight" in testcase:
            testcase_dict["config"]["weight"] = testcase["weight"]

        # make testcase
        # # 将有效的testcase dict转换为pytest文件路径
        testcase_pytest_path = make_testcase(testcase_dict, testsuite_dir)
        # 保存生成的pytest文件以运行，引用的testcase除外
        pytest_files_run_set.add(testcase_pytest_path)

# 使用testcase/testsuite/folder绝对路径生成testcase
# 生成的pytest文件路径将缓存在pytest_files_made_cache_mapping
def __make(tests_path: Text) -> NoReturn:
    """ make testcase(s) with testcase/testsuite/folder absolute path
        使用testcase/testsuite/folder绝对路径生成testcase
        generated pytest file path will be cached in pytest_files_made_cache_mapping
        生成的pytest文件路径将缓存在pytest_files_made_cache_mapping

    Args:
        tests_path: should be in absolute path 绝对路径

    """
    logger.info(f"make path: {tests_path}")
    test_files = []
    # 判断路径是否为目录
    if os.path.isdir(tests_path):
        # 加载文件夹路径，返回列表中的所有文件结尾为.yml/.yaml/.json/_test.py。
        files_list = load_folder_files(tests_path)
        test_files.extend(files_list)
    # 判断路径是否为文件
    elif os.path.isfile(tests_path):
        test_files.append(tests_path)
    else:
        # 无效的测试路径
        raise exceptions.TestcaseNotFound(f"Invalid tests path: {tests_path}")

    for test_file in test_files:
        # 先转为小写，如果是以_test.py结尾
        if test_file.lower().endswith("_test.py"):
            # 加入pytest_files文件集合
            pytest_files_run_set.add(test_file)
            continue

        try:
            # 加载testcase/testsuite文件内容
            test_content = load_test_file(test_file)
        except (exceptions.FileNotFound, exceptions.FileFormatError) as ex:
            # 无效的测试文件
            logger.warning(f"Invalid test file: {test_file}\n{type(ex).__name__}: {ex}")
            continue
        # 如果加载的testcase/testsuite文件内容不是字典
        if not isinstance(test_content, Dict):
            logger.warning(
                f"Invalid test file: {test_file}\n"
                f"reason: test content not in dict format."
            )
            continue

        # api in v2 format, convert to v3 testcase
        # v2格式的api，转换为v3测试用例
        if "request" in test_content and "name" in test_content:
            # 将v2中的api转换为testcase格式v3
            test_content = ensure_testcase_v3_api(test_content)
        # 判断字典中是否有config
        if "config" not in test_content:
            logger.warning(
                f"Invalid testcase/testsuite file: {test_file}\n"
                f"reason: missing config part."
            )
            continue
        # 判断字典中中config是否为字典
        elif not isinstance(test_content["config"], Dict):
            logger.warning(
                f"Invalid testcase/testsuite file: {test_file}\n"
                f"reason: config should be dict type, got {test_content['config']}"
            )
            continue

        # ensure path absolute 确保绝对路径
        test_content.setdefault("config", {})["path"] = test_file

        # testcase 获取teststeps测试步骤
        if "teststeps" in test_content:
            try:
                # 将有效的testcase dict转换为pytest文件路径
                testcase_pytest_path = make_testcase(test_content)
                # 将pytest文件路径加入集合中
                pytest_files_run_set.add(testcase_pytest_path)
            except exceptions.TestCaseFormatError as ex:
                logger.warning(
                    f"Invalid testcase file: {test_file}\n{type(ex).__name__}: {ex}"
                )
                continue

        # testsuite
        elif "testcases" in test_content:
            try:
                # 使用testcases将有效的testsuite dict转换为pytest文件到文件夹中
                make_testsuite(test_content)
            except exceptions.TestSuiteFormatError as ex:
                logger.warning(
                    f"Invalid testsuite file: {test_file}\n{type(ex).__name__}: {ex}"
                )
                continue

        # invalid format
        # 无效的步骤
        else:
            logger.warning(
                f"Invalid test file: {test_file}\n"
                f"reason: file content is neither testcase nor testsuite"
            )

# 程序入口，制作测试用例入口
def main_make(tests_paths: List[Text]) -> List[Text]:
    if not tests_paths:
        return []
    # 变量文件路径列表
    for tests_path in tests_paths:
        # 确保linux和windows的不同路径分隔符兼容
        tests_path = ensure_path_sep(tests_path)
        # 如果不是绝对路径，变为绝对路径
        if not os.path.isabs(tests_path):
            tests_path = os.path.join(os.getcwd(), tests_path)

        try:
            # 使用testcase/testsuite/folder绝对路径生成testcase
            # 生成的pytest文件路径将缓存在pytest_files_made_cache_mapping
            __make(tests_path)
        except exceptions.MyBaseError as ex:
            logger.error(ex)
            sys.exit(1)

    # format pytest files 格式化pytest文件
    # 获取pytest文件路径列表
    pytest_files_format_list = pytest_files_made_cache_mapping.keys()
    # 用“black”库，设置文件格式
    format_pytest_with_black(*pytest_files_format_list)

    return list(pytest_files_run_set)

# 生成测试用例：解析命令行选项并运行命令。
def init_make_parser(subparsers):
    """ make testcases: parse command line options and run commands.
    """
    parser = subparsers.add_parser(
        "make", help="Convert YAML/JSON testcases to pytest cases.",
    )
    parser.add_argument(
        "testcase_path", nargs="*", help="Specify YAML/JSON testcase file/folder path"
    )

    return parser
